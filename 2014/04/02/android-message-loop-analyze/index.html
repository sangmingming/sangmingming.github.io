<!DOCTYPE html><html lang="Chinese"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android消息循环分析 · 码农明明桑</title><meta name="description" content="Android消息循环分析 - Sam"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.isming.me/atom.xml" title="码农明明桑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><!--img(src=url_for(theme.logo) alt="logo")--><h1>码农明明桑</h1></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/links" target="_self" class="nav-list-link">FRIENDS</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android消息循环分析</h1><div class="post-info">Apr 2, 2014</div><div class="post-content"><p>我们的常用的系统中，程序的工作通常是有事件驱动和消息驱动两种方式，在Android系统中，Java应用程序是靠消息驱动来工作的。</p>
<p>消息驱动的原理就是：       </p>
<pre><code>1. 有一个消息队列，可以往这个队列中投递消息;      
2. 有一个消息循环，不断从消息队列中取出消息，然后进行处理。       
</code></pre><p>在Android中通过Looper来封装消息循环，同时在其中封装了一个消息队列MessageQueue。<br>另外Android给我们提供了一个封装类，来执行消息的投递，消息的处理，即Handler。<br><a id="more"></a> </p>
<h4 id="在我们的线程中实现消息循环时，需要创建Looper，如："><a href="#在我们的线程中实现消息循环时，需要创建Looper，如：" class="headerlink" title="在我们的线程中实现消息循环时，需要创建Looper，如："></a>在我们的线程中实现消息循环时，需要创建Looper，如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class LooperThread extends Thread &#123;</div><div class="line">	public Handler mHandler;</div><div class="line">	public void run() &#123;</div><div class="line">		Looper.prepare(); //1.调用prepare</div><div class="line">		......</div><div class="line">		Looper.loop();	//2.进入消息循环</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面的代码，其实就是先准备Looper，然后进入消息循环。     </p>
<ol>
<li>在prepare的时候，创建一个Looper，同时在Looper的构造方法中创建一个消息队列MessageQueue，同时将Looper保存到TLV中<code>（这个是关于ThreadLocal的，不太懂，以后研究了再说）</code>     </li>
<li>调用loop进入消息循环，此处其实就是不断到MessageQueue中取消息<code>Message</code>，进行处理。     </li>
</ol>
<h4 id="然后再看我们如何借助Handler来发消息到队列和处理消息"><a href="#然后再看我们如何借助Handler来发消息到队列和处理消息" class="headerlink" title="然后再看我们如何借助Handler来发消息到队列和处理消息"></a>然后再看我们如何借助Handler来发消息到队列和处理消息</h4><p>Handler的成员(非全部)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final MessageQueue mQueue;    </div><div class="line">final Looper mLooper;    </div><div class="line">final Callback mCallback;</div></pre></td></tr></table></figure></p>
<p>Message的成员(非全部)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Handler target;            </div><div class="line">Runnable callback;</div></pre></td></tr></table></figure></p>
<p>可以看到Handler的成员包含Looper，通过查看源代码，我们可以发现这个Looper是有两种方式获得的，1是在构造函数传进来，2是使用当前线程的Looper（如果当前线程无Looper，则会报错。我们在Activity中创建Handler不需要传Handler是因为Activity本身已经有一个Looper了），MessageQueue也就是Looper中的消息队列。</p>
<p>然后我们看怎么向消息队列发送消息，Handler有很多方法发送队列（这个自己可以去查），比如我们看sendMessageDelayed（Message msg， long delayMillis）</p>
<pre><code>public final boolean sendMessageDelayed(Message msg, long delayMillis) {
    if (delayMillis &lt; 0) {    
        delayMillis = 0;    
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);      
// SystemClock.uptimeMillis() 获取开机到现在的时间    
} 
    //最终所有的消息是通过这个发，uptimeMillis是绝对时间（从开机那一秒算起）
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {    
    boolean sent = false;    
    MessageQueue queue = mQueue;    
    if (queue != null) {    
        msg.target = this;    
        sent = queue.enqueueMessage(msg, uptimeMillis);    
    }   
    return sent;   
}
</code></pre><p>看上面的的代码，可以看到Handler将自己设为Message的target，然后然后将msg放到队列中，并且指定执行时间。</p>
<h4 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h4><p>处理消息，即Looper从MessageQueue中取出队列后，调用msg.target的dispatchMessage方法进行处理，此时会按照消息处理的优先级来处理：    </p>
<ol>
<li>若msg本身有callback，则交其处理;    </li>
<li>若Handler有全局callback,则交由其处理;    </li>
<li>以上两种都没有，则交给Handler子类实现的handleMessage处理，此时需要重载handleMessage。    </li>
</ol>
<p>我们通常采用第三种方式进行处理。</p>
<h3 id="注意！！！！我们一般是采用多线程，当创建Handler时，LooperThread中可能还未完成Looper的创建，此时，Handler中无Looper，操作会报错。"><a href="#注意！！！！我们一般是采用多线程，当创建Handler时，LooperThread中可能还未完成Looper的创建，此时，Handler中无Looper，操作会报错。" class="headerlink" title="注意！！！！我们一般是采用多线程，当创建Handler时，LooperThread中可能还未完成Looper的创建，此时，Handler中无Looper，操作会报错。"></a>注意！！！！我们一般是采用多线程，当创建Handler时，LooperThread中可能还未完成Looper的创建，此时，Handler中无Looper，操作会报错。</h3><p>我们可以采用Android为我们提供的HandlerThread来解决，该类已经创建了Looper，并且通过wait/notifyAll来避免错误的发生，减少我们重复造车的事情。我们创建该对象后，调用getLooper（）即可获得Looper（Looper未创建时会等待）。</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>本文所属为Android中java层的消息循环机制，其在Native层还有消息循环，有单独的Looper。并且2.3以后MessageQueue的核心向Native层下移，native层java层均可以使用。这个我没有过多的研究了！哈哈</p>
<h6 id="PS：本文参考《深入理解Android：卷I》"><a href="#PS：本文参考《深入理解Android：卷I》" class="headerlink" title="PS：本文参考《深入理解Android：卷I》"></a>PS：本文参考《深入理解Android：卷I》</h6></div></article></div></main><footer><div class="paginator"><a href="/2014/04/09/use-git-rsync-site/" class="prev">上一篇</a><a href="/2014/03/25/manage-activityde-lifecycle/" class="next">下一篇</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "2014/04/02/android-message-loop-analyze/",
    productKey: "a094f65b0cf3436d922737584f8a4bb2",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);</script><div class="copyright"><p>© 2013 - 2017 <a href="http://blog.isming.me">Sam</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//hm.baidu.com/h.js?c22f102f5fbaa79cf43b93add1805f4f"></script></body></html>